---
title: 深入理解JVM原理 第2章 java运行时数据区
date: 2018-08-12 19:55:51
tags: 
  - JVM原理 
  - java运行时数据区
  - 对象创建
  - 对象访问定位
categories: JVM虚拟机原理
top: 1
image: https://medesqure.oss-cn-hangzhou.aliyuncs.com/undertale-frisk-flowers-anime-style-back-view-29102.jpeg

--- 

# Java内存区域与内存溢出异常
## 运行时数据区域

java虚拟机在运行程序时会把管理的内存分为几个不同的数据区域，这些区域的作用不同并且创建和销毁的时间不同。java虚拟机将管理的内存分为以下几个数据区域。
<!-- more -->

```
线程共享部分
1. 方法区
2. 堆
线程私有部分
3. 虚拟机栈
4. 本地方法栈
5. 程序计数器
```

![15286130089914](
https://medesqure.oss-cn-hangzhou.aliyuncs.com/15286130089914-1.jpg)

### 程序计数器
一块比较小的内存区域，看成当前线程执行字节码的行号指示器。通过改变这个值来取下一条的指令，分支、循环、跳转、异常处理、线程恢复都是靠这个计数器来完成。
java的多线程时通过线程轮流切换并分配处理器的执行时间来实现。为了线程切换后能恢复到正确的执行位置，每个线程需要独立的程序计数器，各个线程的程序计数器相互不影响。
如果线程执行java方法，这个计数器记录正在执行的虚拟机字节码指令的地址，如果是执行native方法，计数器的值为空(undefined)。此内存区域为java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### 虚拟机栈
java虚拟机栈也是线程私有的，生命周期和线程相同。虚拟机栈描述的java方法执行的内存模型。在调用方法的同时会创建一个栈帧来存储**局部变量表，操作数栈，动态链接，方法出口**等信息。<u>每一个方法从调用到执行完毕对应栈帧在虚拟机栈中的入栈到出栈的过程。</u>
#### 局部变量表
局部变量表中存放的是编译期间可知的基本数据类型(boolean, byte, char, short, int, float, long, double)、对象引用(reference类型),对象引用不是对象本身，可能是指向对象起始地址的地址指针。其中long和double数据类型占用2个slot槽，其余占用一个slot槽。**一个槽指向一个地址，long和double需要两个地址空间存放64位的数据，则需要两个slot**。局部变量表所需的空间在编译期间完成，在运行期间不会改变局部变量表的大小。

* 在方法中声明的是基本类型的变量时，变量名和值(变量名和值时两个概念)是存放在方法栈中，申明的是引用变量时，对象的内存地址是存放在栈中。
* 类中声明的是基本基本变量，称为全局变量，变量名和值都是存放在堆中。引用类型存放的是对象的地址。

> int a = 3只会生成一个slot空间。在编译成汇编时a只是一个符号，可以认为是一个偏移地址2000，mov 0xffsa 2 而在a映射的地址中存放的值是3。所以只有一个slot空间。如果是Integer a = new Integer(3) 那么a中存放的是堆对象3的地址。所以生成了2个空间。

在java虚拟机规范中对这个区域规范两种异常，线程请求的栈深度超过虚拟机提供的深度，抛出StackOverflowError异常，如果方法无法申请足够的内存，抛出OutOfMemoryError异常。

### 本地方法栈
本地方法栈和虚拟机栈类似。只是本地方法栈是为虚拟机使用到的native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

### java堆
Java堆是虚拟机管理内存最大的部分。是线程共享的。在虚拟机启动的时候创建，存放的是实例对象。 从堆空间划分看，java堆可以分为新生代和老年代。新生代中分为Eden空间、From Survivor空间和To Survivor空间。java堆是垃圾收集器管理的主要部分，所以也称为GC堆。 从内存分配角度看，线程共享的java堆中可以划分出线程私有的分配缓冲区(TLAB thread local allcation buffer)。java堆在物理上可以处于不连续的内存空间中，只要逻辑上连续就可以了。
java堆实现上可以采用固定大小的或者是可扩展的，主流的虚拟机都是按照扩展实现的(通过-Xmx和-Xms控制)。如果在堆上没有内存完成实例分配，并且堆不能扩展，就会抛出OutMemeoryOfError异常。

### 方法区
方法区中存放的是被虚拟机加载的类信息(static变量)、常量，编译器编译后的代码等等。GC分代收集扩展至方法区。方法区的gc回收采用永久代的回收方法。
#### 运行时常量池 
**运行时常量池**是方法区的一部分。class文件中除了类的版本，字段，方法等信息还有就是**常量池**(constant pool table)，存放编译期间生成的各种字面量和符号引用，Class**常量池**的内容在该Class被加载后会进入方法区的**运行时常量池**中。在运行期间也会将新的常量放入池内。比如String的intern()方法。除了Class文件中描述的符号引用外，符号引用翻译出来的直接引用也会存储在**运行时常量池**中。

### 直接内存
在NIO类中，引入了基于通道(channel)与缓冲区(Buffer)的I/O方法，<u>可以使用Native函数直接在堆外分配内存，然后通过存储在java堆中的DirectByteBuffer对象作为这个内存的引用操作</u>。可以提高性能，避免在Java堆和native堆中来回复制数据。
显然，本机直接内存不会受到java堆大小的限制，但是受到本机的物理内存的影响。

### 对象的创建过程

1. 当虚拟机遇到一个new指令，首先检查这个指令的参数在常量池能定位到一个符号引用，再检查这个符号引用的类是否被加载，解析和初始化，没有要先执行类加载过程。
2. 将一块等同该对象大小的空间从java堆中划分出来，一般是维护一个队列，记录可用的内存。为了保证分配对象的线程安全, (1).使用TLAB来分配(2).使用CAS来进行失败重试保证内存分配的原子性。
3. 分配完对象，需要对内存空间进行初始化为零值。并且设置对象的对象头的一些值，比如哈希值，GC年代等等。
4. 上述工作完成后，虚拟机角度看一个对象产生了，但是从java程序看，对象还没有初始化，因为没有执行<init>方法。

### 对象的内存布局
在虚拟机中，一个对象在内存中的分配区域主要有：对象头，实例数据，对其补充。如图所示
![](https://medesqure.oss-cn-hangzhou.aliyuncs.com/img/20190622151259.png)

#### 对象头
对象头中主要有Mark Word和指向class元类型的指针。

* 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳、对象分代年龄，这部分信息称为“Mark Word”；Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间。
* 第二部分是类型指针，即对象指向它的类元数据的指针，**虚拟机通过这个指针来确定这个对象是哪个类的实例**
如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中无法确定数组的大小。
这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit。 对象头如下所示

![](https://medesqure.oss-cn-hangzhou.aliyuncs.com/img/20190622152304.png)

举个例子，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么 Mark Word 的 32bit 空间中的 25bit 用于存储对象哈希码，4bit 用于存储对象分代年龄，2bit 用于存储锁标志位，1bit 固定为 0，如下表所示：
![](https://medesqure.oss-cn-hangzhou.aliyuncs.com/img/20190622153427.png)
在32位系统下，存放Class指针的空间大小是4字节，Mark Word空间大小也是4字节，因此头部就是8字节，如果是**数组就需要再加4字节表示数组的长度**，如下表所示
![](https://medesqure.oss-cn-hangzhou.aliyuncs.com/img/20190622153531.png)
在64位系统及64位JVM下，开启指针压缩，那么头部存放class指针的空间大小还是4字节，而Mark Word区域会变大，变成8字节，也就是头部最少为12字节，如下表所示：
![](https://medesqure.oss-cn-hangzhou.aliyuncs.com/img/20190622153749.png)
#### 对象实例
实例数据是对象存储的有效信息，在程序代码中定义的各种类型的字段内容。

* 对齐补充
**由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍**。对象头部分是8字节的倍数，所以当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。
* 估算对象大小
32 位系统下，当使用`new Object()时`，JVM 将会分配8(Mark Word+class指针)字节的空间，128个Object对象将占用1KB的空间。
如果是`new Integer()`，那么对象里还有一个int值，其占用4字节，这个对象也就是 8+4=12 字节，最后补齐后，该对象就是16字节。

#### 对象排列

```java
Class A {
    int i;
    byte b;
    String str;
}
```
对象头部 = Mark Word占4个字节 + 类型指针占4个字节 = 8字节
对象body = int 32位占用4个字节 + byte 8位占用1字节 + String只有引用占用4字节 = 9字节
那么对象A一共占用了8+1+4+4=17 字节，按照8字节对齐原则，对象大小也就是24字节。
在 HotSpot VM中，对象排布时，间隙是在4字节基础上的（在 32 位和 64 位压缩模式下），上述例子中，int后面的byte的空隙只剩下3字节，接下来的 String对象引用需要4字节来存放，因此byte和对象引用之间就会有3字节对齐，**对象引用排布后，最后会有4字节对齐**。此时对象的结构示意图，如下图所示：
![](https://medesqure.oss-cn-hangzhou.aliyuncs.com/img/20190622154924.png)

### 对象的访问定位
在访问对象时，通过栈上的reference数据类操作堆上的具体对象。reference类型在具体的访问对象有2种方式

* 使用句柄访问
在java堆中划分一块区域为句柄池，reference存储的是对象的句柄地址，句柄中包含对象的实例地址和对象类型。对象类型是通过对象头的指针来访问
![](https://medesqure.oss-cn-hangzhou.aliyuncs.com/img/20190622155113.png)
* 直接指针访问 
reference存储的是对象的直接地址。java采用的是直接访问，对象头中存了class元数据的指针。
![](https://medesqure.oss-cn-hangzhou.aliyuncs.com/img/20190622164355.jpeg)











